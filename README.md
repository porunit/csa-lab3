# csa-lab3

---
Шпак Всеволод Васильевич P3209
`forth | stack | neum | mc | tick | binary | stream | mem | pstr | prob2`
Выполнен базовый вариант

## Язык программирования

---

### Синтаксис

__Форма Бэкуса-Наура:__

``` форма Бэкуса-Наура
<program> ::= <term> | <term> "\n" <program>

<term> ::= <variables> 
         | <words> 
         | <call_words> 
         | <commands>

<variables> ::= <set_variable> 
              | <variable_on_top_stack>

<string_name> ::= [A-Za-z][A-Za-z0-9]*

<set_variable> ::= <number> <string_name> "!"

<number> ::= -?[1-9][0-9]*

<variable_on_top_stack> ::= <string_name> "@"

<words> ::= ":" <string_name> "\n" <commands> ";"

<call_words> ::= <string_name>

<commands> ::= <command> 
             | <command> "\n" <commands>

<command> ::= "+" 
            | "-" 
            | "*" 
            | "/" 
            | "mod" 
            | "dup" 
            | "drop" 
            | "swap" 
            | "=" 
            | "!=" 
            | ">" 
            | "<" 
            | "." 
            | "exit" 
            | "emit"
            | <variables> 
            | <if> 
            | <if_else> 
            | <loop>

<if> ::= "if" <term> "then"

<if_else> ::= "if" <term> "else" <term> "then"

<loop> ::= "begin" <term> "until"

```

### Описание синтаксиса

1. **Программа (`<program>`)**: Это последовательность термов, разделенных новой строкой. Программа может состоять из одного или нескольких термов.
   
2. **Терм (`<term>`)**: Термом может быть переменная, слово (пользовательская функция), вызов слова или команда.

3. **Переменные (`<variables>`)**: Включают операции установки значения переменной (`<set_variable>`) и получение значения переменной на вершину стека (`<variable_on_top_stack>`).

4. **Установка переменной (`<set_variable>`)**: Формат `число имя_переменной "!"`. Устанавливает значение переменной.

5. **Взятие значения переменной (`<variable_on_top_stack>`)**: Формат `имя_переменной "@"`. Кладет значение переменной на вершину стека.

6. **Слова (`<words>`)**: Пользовательские функции, определяемые через двоеточие (`:`) и заканчивающиеся точкой с запятой (`;`).

7. **Команды (`<commands>`)**: Команды могут быть арифметическими, манипуляциями со стеком, операциями ввода/вывода или управляющими конструкциями, такими как условные операторы и циклы.

8. **Условные операторы (`<if>` и `<if_else>`)**: Оператор `if ... then` выполняет терм, если условие истинно, а оператор `if ... else ... then` добавляет ветвление "иначе".

9. **Циклы (`<loop>`)**: Оператор цикла `begin ... until` выполняет термы до тех пор, пока условие не станет истинным.

### Операции
| **Операция**      | **Стек**                   | **Описание**                                                                                  |
|-------------------|----------------------------|-----------------------------------------------------------------------------------------------|
| `+`               | `(... a b)` → `(... a + b)` | Складывает два верхних числа на стеке и кладет сумму на вершину                               |
| `-`               | `(... a b)` → `(... a - b)` | Вычитает b из a и кладет результат на вершину стека                                           |
| `*`               | `(... a b)` → `(... a * b)` | Умножает два верхних числа на стеке и кладет результат на вершину                             |
| `/`               | `(... a b)` → `(... a / b)` | Делит a на b и кладет результат деления на вершину стека                                      |
| `mod`             | `(... a b)` → `(... a mod b)` | Кладет остаток от деления a на b на вершину стека                                              |
| `dup`             | `(... a)` → `(... a a)`     | Дублирует число с вершины стека и кладет копию на вершину                                     |
| `drop`            | `(... a)` → `(...)`         | Удаляет верхний элемент со стека                                                              |
| `swap`            | `(... a b)` → `(... b a)`   | Меняет местами два верхних элемента стека                                                     |
| `=`               | `(... a b)` → `(... a = b)` | Сравнивает два числа на стеке: если a равно b, кладет 1 на вершину, иначе 0                   |
| `!=`              | `(... a b)` → `(... a != b)` | Сравнивает два числа на стеке: если a не равно b, кладет 1 на вершину, иначе 0                |
| `>`               | `(... a b)` → `(... a > b)` | Если a больше b, кладет 1 на вершину стека, иначе 0                                           |
| `<`               | `(... a b)` → `(... a < b)` | Если a меньше b, кладет 1 на вершину стека, иначе 0                                           |
| `.`               | `(... a)` → `output(a)`     | Печатает число с вершины стека                                                                 |
| `exit`            | `-`                         | Завершает выполнение программы                                                               |
| `(a addr) !`      | `(... a addr)` → `(...)`    | Сохраняет значение a по адресу addr                                                          |
| `(addr) @`        | `(... addr)` → `(... a)`    | Читает значение по адресу addr и кладет его на вершину стека                                  |
| `#`               | `input` → `(... a)`         | Считывает число из ввода и кладет его на вершину стека                                       |
| `if`              | `a == True` → `ip++, jmp n` | Если a на вершине стека истина (не 0), переходит к следующим инструкциям, иначе к `else`       |
| `else`            | -                           | Выполняется, если при команде `if` на вершине стека ложь (0)                                  |
| `endif`           | -                           | Завершает блок условия `if`, программа продолжает выполнение                                  |
| `begin`           | -                           | Начало цикла, к которому программа возвращается при команде `until`                           |
| `until`           | `(... a)` → `(...)`         | Если a на вершине стека истина (не 0), завершает цикл, иначе возвращает выполнение к `begin`   |
| `emit`            | `(... a)` → `output(ascii(a))` | Печатает значение a как символ ASCII                                                           |

### Специальные конструкции:

- **`: <слово> <команды> ;`** — Определение процедуры (пользовательского слова).
- **`if <true-команды> [else <false-команды>] endif`** — Условная конструкция: выполняет `<true-команды>`, если a на стеке не 0, иначе выполняет `<false-команды>`, если они присутствуют.
- **`begin <команды> until`** — Цикл: продолжает выполнение команд до тех пор, пока a на вершине стека не станет ложным (0).
- **`." <строка>"`** — Вывод строки `<строка>` на стандартный вывод.

### Организация памяти

---

### Описание организации памяти

Память машины организована в соответствии с архитектурой фон Неймана, где команды и данные хранятся в одной общей памяти. Память машины используется для хранения программы, данных и переменных, а также имеет **Stack**, который используется хранения операндов для вычислений, результатов вычислений и т.д.

#### Основные элементы памяти:
1. **Общая память** — используется как для хранения программных команд, так и для данных (переменных).
2. **Stack** — стек данных, который может использоваться для выполнения арифметических операций, управления и обработки переменных в ходе выполнения программы.
3. **Регистр адреса (AR)** — регистр, через который производится обращение к памяти. Он хранит адрес ячейки памяти, к которой обращается машина для чтения или записи данных.

#### Структура памяти:

1. **Область программы**: 
   - В начале памяти хранится сама программа. Команды программы последовательно записываются как машинные слова.
   - **Адрес начала переменных** — перед началом переменных существует специальный указатель, который указывает на область памяти, где начинаются переменные программы.

2. **Область переменных**:
   - Переменные программы хранятся в памяти сразу после области программы. Обращение к ним осуществляется через команду адресации переменной, например через команды `!` и `@`.
   - В инструкции `!` значение сохраняется по адресу переменной, а в инструкции `@` значение переменной загружается на вершину стека данных.


#### Архитектура стека (Data Stack):
- Стек данных используется для временного хранения значений и результатов вычислений. Все команды языка работают с вершиной стека:
  - Команды арифметических операций (`+`, `-`, `*`, `/`, `mod`) производят вычисления на значениях, находящихся на вершине стека.
  - Стек может изменяться командами вроде `dup` (дублирование), `swap` (смена мест двух верхних значений) и `drop` (удаление значения с вершины стека).

#### Пример работы с памятью:
Программа хранится в первых ячейках памяти и выполняется последовательно. Например:

- **Чтение переменной**:
  ```
  addr_variable @
  ```
  Это приведет к тому, что адрес переменной загрузится в регистр `address_register`, и значение по этому адресу будет загружено на стек.

- **Запись переменной**:
  ```
  addr_variable !
  ```
  Значение на вершине стека будет записано в память по адресу, указанному в `address_register`.

#### Адресация памяти:
- Память представлена последовательностью адресов, которые доступны через указатели. Программный код может управлять указателями и работать с переменными через команды адресации.
- Для упрощения работы программиста используются относительные и абсолютные адреса, в зависимости от типа программы и структуры переменных.

### Система команд

---
Система команд представлена микрокодом, который описывает последовательность микропроцессорных шагов для выполнения каждой инструкции. Команды управляют различными компонентами процессора, такими как стек данных, ALU (арифметико-логическое устройство), регистры и управляющие блоки. 

#### Набор инструкций

---
1. **Fetch** (Получение следующей инструкции)
    - Выполняется в начале каждой команды.
    - Загружает следующую инструкцию в регистр команд (IR) и увеличивает счетчик команд (PC).

2. **SUM** (Сложение)
    - Чтение операндов и выполнение операции сложения в ALU.
    - Запись результата обратно в стек данных.
    - Увеличение счетчика команд и возврат к началу микрокода.

3. **SUB** (Вычитание)
    - Чтение операндов и выполнение операции вычитания в ALU.
    - Запись результата обратно в стек данных.
    - Увеличение счетчика команд.

4. **MUL** (Умножение)
    - Чтение операндов и выполнение операции умножения в ALU.
    - Запись результата в стек.

5. **DIV** (Деление)
    - Чтение операндов и выполнение операции деления в ALU.
    - Запись результата на вершину стека.

6. **MOD** (Остаток от деления)
    - Чтение операндов и вычисление остатка от деления в ALU.
    - Запись результата.

7. **DUP** (Дублирование)
    - Дублирование значения с вершины стека.
    - Увеличение счетчика команд.

8. **DROP** (Удаление)
    - Удаление верхнего значения со стека данных.

9. **SWAP** (Обмен)
    - Обмен двух верхних значений стека.

10. **EQ** (Равно)
    - Сравнение двух верхних значений.
    - Если они равны, на вершину стека записывается 1, иначе 0.

11. **MORE** (Больше)
    - Сравнение двух верхних значений.
    - Если первое значение больше второго, записывается 1, иначе 0.

12. **LESS** (Меньше)
    - Сравнение двух верхних значений.
    - Если первое значение меньше второго, записывается 1, иначе 0.

13. **PUSH** (Запись значения в стек)
    - Записывает непосредственное значение из регистра команд (IR) на стек.

14. **ADR_ON_TOP** (Адрес на вершину стека)
    - Записывает адрес переменной на вершину стека.

15. **SAVE_VAR** (Сохранить переменную)
    - Сохраняет значение с вершины стека в память по адресу, находящемуся на второй позиции стека.

16. **VAR_ON_TOP** (Загрузка переменной)
    - Чтение значения из памяти по адресу на вершине стека.

17. **JZS** (Прыжок, если 0)
    - Если значение на вершине стека равно 0, осуществляется переход по указанному адресу.

18. **JMP** (Безусловный прыжок)
    - Переход по указанному адресу.

19. **PRINT** (Вывод числа)
    - Выводит верхнее значение стека в стандартный вывод.

20. **READ** (Чтение)
    - Считывает значение из ввода пользователя и кладет его на стек данных.

21. **EMIT** (Вывод символа)
    - Выводит символ, соответствующий числовому значению на вершине стека.

22. **HALT** (Остановка программы)
    - Завершает выполнение программы.

23. **NOT_EQ** (Не равно)
    - Сравнивает два значения на вершине стека. Если они не равны, записывает 1 на вершину стека, иначе 0.

### Транслятор

---

Интерфейс командной строки: `translator.py <source.file> <target.file>`  
Реализован в [translator.py](translator.py)

#### Этапы транслирования

1. **Парсинг исходного кода**: 
   Исходный текст программы разбивается на токены, такие как команды, переменные и управляющие структуры (циклы, условные операторы).

2. **Обработка переменных**: 
   Переменные сохраняются в таблицу с указанием их адресов в памяти.

3. **Генерация машинного кода**:
   Для каждой команды создается соответствующая машинная инструкция на основе таблицы операций.

4. **Обработка управляющих конструкций**: 
   Обрабатываются циклы (`begin-until`) и условные операторы (`if-else-endif`) с корректной генерацией инструкций для переходов.

5. **Поддержка строк**: 
   Специальные команды для вывода строк транслируются в последовательность машинных инструкций, которые управляют выводом строк.

6. **Запись результата**:
   Сгенерированные инструкции сохраняются в выходной файл для дальнейшего выполнения. 

### Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_file> <debug_file>`

#### DataPath

![datapath](resources/DataPath.drawio.svg)

Реализован в классе [DataPath](data_path.py)  
`IR` - регистр для хранения машинного слова  
`IP` - указатель на место в памяти, от куда брать следующее машинное слово  
`AR` - регистр для хранения адреса, по которому программа обращается к памяти  
`TOS` - регистр для хранения вершины стека  
`BR` - регистр для для промежуточного хранения из DataStack  
`DataStack` - стек данных  
`Memory` - общая память программы  
На схеме также изображены сигналы, которые приходят из `ControlUnit`, по которым выполняется определенное действие  

#### ControlUnit

![control_unit](resources/ControlUnit.drawio.svg)
Реализован в классе [ControlUnit](control_unit.py)  
`mc_adr` - регистр для хранения адреса микрокоманды, которую надо выполнить  
`MicrocodeMemory` - память микрокоманд, где прописана каждая интрукция  
Считывает по адресу массив сигналов, выполняет каждый из них и отсылает в нужное место  
Тики считают, сколько сигналов было отправлено

#### Сигналы

1. **DataStackControl**
   - **Push (0)**: Добавляет текущее значение на вершину стека данных.
   - **Pop (1)**: Удаляет значение с вершины стека данных.

2. **AddressRegisterControl**
   - **IP (0)**: Управляет адресным регистром, устанавливая его на текущий указатель инструкции (IP).
   - **TOS (1)**: Устанавливает адресный регистр на значение вершины стека данных (TOS).

3. **InstructionRegisterControl**
   - **MEM (0)**: Загружает текущее значение из памяти в регистр инструкций (IR).

4. **InstractionPointerControl**
   - **IR (0)**: Устанавливает указатель инструкций (IP) на значение, хранящееся в регистре инструкций (IR).
   - **INC (1)**: Увеличивает указатель инструкций (IP) на 1, переходя к следующей инструкции.

5. **TopOfStackControl**
   - **MEM (0)**: Загружает в вершину стека (TOS) значение из памяти.
   - **IR (1)**: Устанавливает вершину стека на значение из регистра инструкций (IR).
   - **BR (2)**: Загружает в вершину стека значение из буферного регистра (BR).
   - **ALU (3)**: Загружает в вершину стека результат выполнения операции ALU (арифметико-логического устройства).
   - **IR_VAR (4)**: Устанавливает вершину стека на значение, представляющее собой адрес переменной, вычисленный из регистра инструкций.
   - **IO (5)**: Использует значение на вершине стека для операций ввода-вывода (IO).

6. **ALUValuesControl**
   - **VAR (0)**: Загружает значения для выполнения операции ALU (переменные для операций).

7. **AluOperation**
   - **SUM (0)**: Выполняет сложение.
   - **SUB (1)**: Выполняет вычитание.
   - **MUL (2)**: Выполняет умножение.
   - **DIV (3)**: Выполняет деление.
   - **MOD (4)**: Выполняет операцию взятия остатка (mod).
   - **NOT_EQ (5)**: Сравнивает два значения, если они не равны, результат — 1, иначе — 0.
   - **EQ (6)**: Сравнивает два значения на равенство, если равны — результат 1, иначе — 0.
   - **MORE (7)**: Сравнивает два значения, если первое больше второго — результат 1, иначе — 0.
   - **LESS (8)**: Сравнивает два значения, если первое меньше второго — результат 1, иначе — 0.

8. **MemoryControl**
   - **READ (0)**: Чтение данных из памяти по указанному адресу.
   - **WRITE (1)**: Запись данных в память по указанному адресу.
   - **TOS (2)**: Записывает значение из вершины стека в текущий адрес памяти.

9. **MicrocodeAddressControl**
   - **IR (0)**: Устанавливает адрес микрокода в соответствии с кодом операции из регистра инструкций (IR).
   - **INC (1)**: Увеличивает адрес микрокода на 1.
   - **ZERO (2)**: Сбрасывает адрес микрокода в 0 для начала выполнения новой инструкции.

10. **BufferRegisterControl**
    - **DS (0)**: Записывает значение из буферного регистра (BR) в стек данных (DS).

11. **FlagCheck**
    - **z (0)**: Проверка флага нуля (zero flag), используется для ветвлений и условий.
    - **n (1)**: Проверка флага отрицательного результата (negative flag), используется для условий.
    - **v (2)**: Проверка флага переполнения (overflow flag), используется для контроля переполнений.

12. **JumpOperation**
    - **JMP (0)**: Безусловный переход (прыжок) на адрес, указанный в вершине стека.
    - **JZS (1)**: Переход на адрес из вершины стека, если флаг нуля (z) установлен.

13. **IOOperation**
    - **PRINT (0)**: Выводит текущее значение вершины стека в выходной буфер как число.
    - **READ (1)**: Чтение данных из ввода, кладет прочитанное значение на вершину стека.
    - **EMIT (2)**: Выводит значение с вершины стека как символ ASCII.

14. **ProgramControl**
    - **HALT (0)**: Останавливает выполнение программы.

15. **InstructionControl**
    - **INC (0)**: Увеличивает счетчик инструкций, переходя к следующей команде.
