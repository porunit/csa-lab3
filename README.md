# Эмулятор Стекового Процессора

---
`forth | stack | neum | mc | tick | struct | stream | mem | pstr | prob2`
## Язык программирования

---

### Синтаксис

__Форма Бэкуса-Наура:__

``` форма Бэкуса-Наура
<program> ::= <term> | <term> "\n" <program>

<term> ::= <variables> 
         | <words> 
         | <call_words> 
         | <commands>

<variables> ::= <set_variable> 
              | <variable_on_top_stack>

<string_name> ::= [A-Za-z][A-Za-z0-9]*

<set_variable> ::= <number> <string_name> "!"

<number> ::= -?[1-9][0-9]*

<variable_on_top_stack> ::= <string_name> "@"

<words> ::= ":" <string_name> "\n" <commands> ";"

<call_words> ::= <string_name>

<commands> ::= <command> 
             | <command> "\n" <commands>

<command> ::= "+" 
            | "-" 
            | "*" 
            | "/" 
            | "mod" 
            | "dup" 
            | "drop" 
            | "swap" 
            | "=" 
            | "!=" 
            | ">" 
            | "<" 
            | "." 
            | "exit" 
            | "emit"
            | <variables> 
            | <if> 
            | <if_else> 
            | <loop>

<if> ::= "if" <term> "then"

<if_else> ::= "if" <term> "else" <term> "then"

<loop> ::= "begin" <term> "until"

```

### Описание синтаксиса

1. **Программа (`<program>`)**: Это последовательность термов, разделенных новой строкой. Программа может состоять из одного или нескольких термов.
   
2. **Терм (`<term>`)**: Термом может быть переменная, слово (пользовательская функция), вызов слова или команда.

3. **Переменные (`<variables>`)**: Включают операции установки значения переменной (`<set_variable>`) и получение значения переменной на вершину стека (`<variable_on_top_stack>`).

4. **Установка переменной (`<set_variable>`)**: Формат `число имя_переменной "!"`. Устанавливает значение переменной.

5. **Взятие значения переменной (`<variable_on_top_stack>`)**: Формат `имя_переменной "@"`. Кладет значение переменной на вершину стека.

6. **Слова (`<words>`)**: Пользовательские функции, определяемые через двоеточие (`:`) и заканчивающиеся точкой с запятой (`;`).

7. **Команды (`<commands>`)**: Команды могут быть арифметическими, манипуляциями со стеком, операциями ввода/вывода или управляющими конструкциями, такими как условные операторы и циклы.

8. **Условные операторы (`<if>` и `<if_else>`)**: Оператор `if ... then` выполняет терм, если условие истинно, а оператор `if ... else ... then` добавляет ветвление "иначе".

9. **Циклы (`<loop>`)**: Оператор цикла `begin ... until` выполняет термы до тех пор, пока условие не станет истинным.

### Операции
| **Операция**      | **Стек**                   | **Описание**                                                                                  |
|-------------------|----------------------------|-----------------------------------------------------------------------------------------------|
| `+`               | `(... a b)` → `(... a + b)` | Складывает два верхних числа на стеке и кладет сумму на вершину                               |
| `-`               | `(... a b)` → `(... a - b)` | Вычитает b из a и кладет результат на вершину стека                                           |
| `*`               | `(... a b)` → `(... a * b)` | Умножает два верхних числа на стеке и кладет результат на вершину                             |
| `/`               | `(... a b)` → `(... a / b)` | Делит a на b и кладет результат деления на вершину стека                                      |
| `mod`             | `(... a b)` → `(... a mod b)` | Кладет остаток от деления a на b на вершину стека                                              |
| `dup`             | `(... a)` → `(... a a)`     | Дублирует число с вершины стека и кладет копию на вершину                                     |
| `drop`            | `(... a)` → `(...)`         | Удаляет верхний элемент со стека                                                              |
| `swap`            | `(... a b)` → `(... b a)`   | Меняет местами два верхних элемента стека                                                     |
| `=`               | `(... a b)` → `(... a = b)` | Сравнивает два числа на стеке: если a равно b, кладет 1 на вершину, иначе 0                   |
| `!=`              | `(... a b)` → `(... a != b)` | Сравнивает два числа на стеке: если a не равно b, кладет 1 на вершину, иначе 0                |
| `>`               | `(... a b)` → `(... a > b)` | Если a больше b, кладет 1 на вершину стека, иначе 0                                           |
| `<`               | `(... a b)` → `(... a < b)` | Если a меньше b, кладет 1 на вершину стека, иначе 0                                           |
| `.`               | `(... a)` → `output(a)`     | Печатает число с вершины стека                                                                 |
| `exit`            | `-`                         | Завершает выполнение программы                                                               |
| `(a addr) !`      | `(... a addr)` → `(...)`    | Сохраняет значение a по адресу addr                                                          |
| `(addr) @`        | `(... addr)` → `(... a)`    | Читает значение по адресу addr и кладет его на вершину стека                                  |
| `#`               | `input` → `(... a)`         | Считывает число из ввода и кладет его на вершину стека                                       |
| `if`              | `a == True` → `ip++, jmp n` | Если a на вершине стека истина (не 0), переходит к следующим инструкциям, иначе к `else`       |
| `else`            | -                           | Выполняется, если при команде `if` на вершине стека ложь (0)                                  |
| `endif`           | -                           | Завершает блок условия `if`, программа продолжает выполнение                                  |
| `begin`           | -                           | Начало цикла, к которому программа возвращается при команде `until`                           |
| `until`           | `(... a)` → `(...)`         | Если a на вершине стека истина (не 0), завершает цикл, иначе возвращает выполнение к `begin`   |
| `emit`            | `(... a)` → `output(ascii(a))` | Печатает значение a как символ ASCII                                                           |

### Специальные конструкции:

- **`: <слово> <команды> ;`** — Определение процедуры (пользовательского слова).
- **`if <true-команды> [else <false-команды>] endif`** — Условная конструкция: выполняет `<true-команды>`, если a на стеке не 0, иначе выполняет `<false-команды>`, если они присутствуют.
- **`begin <команды> until`** — Цикл: продолжает выполнение команд до тех пор, пока a на вершине стека не станет ложным (0).
- **`." <строка>"`** — Вывод строки `<строка>` на стандартный вывод.

### Организация памяти

---

### Описание организации памяти

Память машины организована в соответствии с архитектурой фон Неймана, где команды и данные хранятся в одной общей памяти. Память машины используется для хранения программы, данных и переменных, а также имеет **Stack**, который используется хранения операндов для вычислений, результатов вычислений и т.д.

#### Основные элементы памяти:
1. **Общая память** — используется как для хранения программных команд, так и для данных (переменных).
2. **Stack** — стек данных, который может использоваться для выполнения арифметических операций, управления и обработки переменных в ходе выполнения программы.
3. **Регистр адреса (AR)** — регистр, через который производится обращение к памяти. Он хранит адрес ячейки памяти, к которой обращается машина для чтения или записи данных.

#### Структура памяти:

1. **Область программы**: 
   - В начале памяти хранится сама программа. Команды программы последовательно записываются как машинные слова.
   - **Адрес начала переменных** — перед началом переменных существует специальный указатель, который указывает на область памяти, где начинаются переменные программы.

2. **Область переменных**:
   - Переменные программы хранятся в памяти сразу после области программы. Обращение к ним осуществляется через команду адресации переменной, например через команды `!` и `@`.
   - В инструкции `!` значение сохраняется по адресу переменной, а в инструкции `@` значение переменной загружается на вершину стека данных.


#### Архитектура стека (Data Stack):
- Стек данных используется для временного хранения значений и результатов вычислений. Все команды языка работают с вершиной стека:
  - Команды арифметических операций (`+`, `-`, `*`, `/`, `mod`) производят вычисления на значениях, находящихся на вершине стека.
  - Стек может изменяться командами вроде `dup` (дублирование), `swap` (смена мест двух верхних значений) и `drop` (удаление значения с вершины стека).

#### Пример работы с памятью:
Программа хранится в первых ячейках памяти и выполняется последовательно. Например:

- **Чтение переменной**:
  ```
  addr_variable @
  ```
  Это приведет к тому, что адрес переменной загрузится в регистр `address_register`, и значение по этому адресу будет загружено на стек.

- **Запись переменной**:
  ```
  addr_variable !
  ```
  Значение на вершине стека будет записано в память по адресу, указанному в `address_register`.

#### Адресация памяти:
- Память представлена последовательностью адресов, которые доступны через указатели. Программный код может управлять указателями и работать с переменными через команды адресации.
- Для упрощения работы программиста используются относительные и абсолютные адреса, в зависимости от типа программы и структуры переменных.

### Система команд

---
Система команд представлена микрокодом, который описывает последовательность микропроцессорных шагов для выполнения каждой инструкции. Команды управляют различными компонентами процессора, такими как стек данных, ALU (арифметико-логическое устройство), регистры и управляющие блоки. 

#### Набор инструкций

---
1. **Fetch** (Получение следующей инструкции)
    - Выполняется в начале каждой команды.
    - Загружает следующую инструкцию в регистр команд (IR) и увеличивает счетчик команд (PC).

2. **SUM** (Сложение)
    - Чтение операндов и выполнение операции сложения в ALU.
    - Запись результата обратно в стек данных.
    - Увеличение счетчика команд и возврат к началу микрокода.

3. **SUB** (Вычитание)
    - Чтение операндов и выполнение операции вычитания в ALU.
    - Запись результата обратно в стек данных.
    - Увеличение счетчика команд.

4. **MUL** (Умножение)
    - Чтение операндов и выполнение операции умножения в ALU.
    - Запись результата в стек.

5. **DIV** (Деление)
    - Чтение операндов и выполнение операции деления в ALU.
    - Запись результата на вершину стека.

6. **MOD** (Остаток от деления)
    - Чтение операндов и вычисление остатка от деления в ALU.
    - Запись результата.

7. **DUP** (Дублирование)
    - Дублирование значения с вершины стека.
    - Увеличение счетчика команд.

8. **DROP** (Удаление)
    - Удаление верхнего значения со стека данных.

9. **SWAP** (Обмен)
    - Обмен двух верхних значений стека.

10. **EQ** (Равно)
    - Сравнение двух верхних значений.
    - Если они равны, на вершину стека записывается 1, иначе 0.

11. **MORE** (Больше)
    - Сравнение двух верхних значений.
    - Если первое значение больше второго, записывается 1, иначе 0.

12. **LESS** (Меньше)
    - Сравнение двух верхних значений.
    - Если первое значение меньше второго, записывается 1, иначе 0.

13. **PUSH** (Запись значения в стек)
    - Записывает непосредственное значение из регистра команд (IR) на стек.

14. **ADR_ON_TOP** (Адрес на вершину стека)
    - Записывает адрес переменной на вершину стека.

15. **SAVE_VAR** (Сохранить переменную)
    - Сохраняет значение с вершины стека в память по адресу, находящемуся на второй позиции стека.

16. **VAR_ON_TOP** (Загрузка переменной)
    - Чтение значения из памяти по адресу на вершине стека.

17. **JZS** (Прыжок, если 0)
    - Если значение на вершине стека равно 0, осуществляется переход по указанному адресу.

18. **JMP** (Безусловный прыжок)
    - Переход по указанному адресу.

19. **PRINT** (Вывод числа)
    - Выводит верхнее значение стека в стандартный вывод.

20. **READ** (Чтение)
    - Считывает значение из ввода пользователя и кладет его на стек данных.

21. **EMIT** (Вывод символа)
    - Выводит символ, соответствующий числовому значению на вершине стека.

22. **HALT** (Остановка программы)
    - Завершает выполнение программы.

23. **NOT_EQ** (Не равно)
    - Сравнивает два значения на вершине стека. Если они не равны, записывает 1 на вершину стека, иначе 0.

### Транслятор

---

Интерфейс командной строки: `translator.py <source.file> <target.file>`  
Реализован в [translator.py](translator.py)

#### Этапы транслирования

1. **Парсинг исходного кода**: 
   Исходный текст программы разбивается на токены, такие как команды, переменные и управляющие структуры (циклы, условные операторы).

2. **Обработка переменных**: 
   Переменные сохраняются в таблицу с указанием их адресов в памяти.

3. **Генерация машинного кода**:
   Для каждой команды создается соответствующая машинная инструкция на основе таблицы операций.

4. **Обработка управляющих конструкций**: 
   Обрабатываются циклы (`begin-until`) и условные операторы (`if-else-endif`) с корректной генерацией инструкций для переходов.

5. **Поддержка строк**: 
   Специальные команды для вывода строк транслируются в последовательность машинных инструкций, которые управляют выводом строк.

6. **Запись результата**:
   Сгенерированные инструкции сохраняются в выходной файл для дальнейшего выполнения. 

### Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_file> <debug_file>`

#### DataPath

![datapath](resources/DataPath.drawio.svg)

Реализован в классе [DataPath](data_path.py)  
`IR` - регистр для хранения машинного слова  
`IP` - указатель на место в памяти, от куда брать следующее машинное слово  
`AR` - регистр для хранения адреса, по которому программа обращается к памяти  
`TOS` - регистр для хранения вершины стека  
`BR` - регистр для для промежуточного хранения из DataStack  
`DataStack` - стек данных  
`Memory` - общая память программы  
На схеме также изображены сигналы, которые приходят из `ControlUnit`, по которым выполняется определенное действие  

#### ControlUnit

![control_unit](resources/ControlUnit.drawio.svg)
Реализован в классе [ControlUnit](control_unit.py)  
`mc_adr` - регистр для хранения адреса микрокоманды, которую надо выполнить  
`MicrocodeMemory` - память микрокоманд, где прописана каждая интрукция  
Считывает по адресу массив сигналов, выполняет каждый из них и отсылает в нужное место  
Тики считают, сколько сигналов было отправлено

#### Сигналы

1. **DataStackControl**
   - **Push (0)**: Добавляет текущее значение на вершину стека данных.
   - **Pop (1)**: Удаляет значение с вершины стека данных.

2. **AddressRegisterControl**
   - **IP (0)**: Управляет адресным регистром, устанавливая его на текущий указатель инструкции (IP).
   - **TOS (1)**: Устанавливает адресный регистр на значение вершины стека данных (TOS).

3. **InstructionRegisterControl**
   - **MEM (0)**: Загружает текущее значение из памяти в регистр инструкций (IR).

4. **InstractionPointerControl**
   - **IR (0)**: Устанавливает указатель инструкций (IP) на значение, хранящееся в регистре инструкций (IR).
   - **INC (1)**: Увеличивает указатель инструкций (IP) на 1, переходя к следующей инструкции.

5. **TopOfStackControl**
   - **MEM (0)**: Загружает в вершину стека (TOS) значение из памяти.
   - **IR (1)**: Устанавливает вершину стека на значение из регистра инструкций (IR).
   - **BR (2)**: Загружает в вершину стека значение из буферного регистра (BR).
   - **ALU (3)**: Загружает в вершину стека результат выполнения операции ALU (арифметико-логического устройства).
   - **IR_VAR (4)**: Устанавливает вершину стека на значение, представляющее собой адрес переменной, вычисленный из регистра инструкций.
   - **IO (5)**: Использует значение на вершине стека для операций ввода-вывода (IO).

6. **ALUValuesControl**
   - **VAR (0)**: Загружает значения для выполнения операции ALU (переменные для операций).

7. **AluOperation**
   - **SUM (0)**: Выполняет сложение.
   - **SUB (1)**: Выполняет вычитание.
   - **MUL (2)**: Выполняет умножение.
   - **DIV (3)**: Выполняет деление.
   - **MOD (4)**: Выполняет операцию взятия остатка (mod).
   - **NOT_EQ (5)**: Сравнивает два значения, если они не равны, результат — 1, иначе — 0.
   - **EQ (6)**: Сравнивает два значения на равенство, если равны — результат 1, иначе — 0.
   - **MORE (7)**: Сравнивает два значения, если первое больше второго — результат 1, иначе — 0.
   - **LESS (8)**: Сравнивает два значения, если первое меньше второго — результат 1, иначе — 0.

8. **MemoryControl**
   - **READ (0)**: Чтение данных из памяти по указанному адресу.
   - **WRITE (1)**: Запись данных в память по указанному адресу.
   - **TOS (2)**: Записывает значение из вершины стека в текущий адрес памяти.

9. **MicrocodeAddressControl**
   - **IR (0)**: Устанавливает адрес микрокода в соответствии с кодом операции из регистра инструкций (IR).
   - **INC (1)**: Увеличивает адрес микрокода на 1.
   - **ZERO (2)**: Сбрасывает адрес микрокода в 0 для начала выполнения новой инструкции.

10. **BufferRegisterControl**
    - **DS (0)**: Записывает значение из буферного регистра (BR) в стек данных (DS).

11. **FlagCheck**
    - **z (0)**: Проверка флага нуля (zero flag), используется для ветвлений и условий.
    - **n (1)**: Проверка флага отрицательного результата (negative flag), используется для условий.
    - **v (2)**: Проверка флага переполнения (overflow flag), используется для контроля переполнений.

12. **JumpOperation**
    - **JMP (0)**: Безусловный переход (прыжок) на адрес, указанный в вершине стека.
    - **JZS (1)**: Переход на адрес из вершины стека, если флаг нуля (z) установлен.

13. **IOOperation**
    - **PRINT (0)**: Выводит текущее значение вершины стека в выходной буфер как число.
    - **READ (1)**: Чтение данных из ввода, кладет прочитанное значение на вершину стека.
    - **EMIT (2)**: Выводит значение с вершины стека как символ ASCII.

14. **ProgramControl**
    - **HALT (0)**: Останавливает выполнение программы.

15. **InstructionControl**
    - **INC (0)**: Увеличивает счетчик инструкций, переходя к следующей команде.

## Тестирование

Тестирование выполняется при помощи golden test-ов.

Тесты реализованы в: [src/golden](./src/golden/)

### Подробное описание программы для вычисления суммы четных чисел последовательности Фибоначчи

Эта программа на основе архитектуры стека и фортообразного синтаксиса вычисляет сумму четных чисел в последовательности Фибоначчи, которые не превышают указанное максимальное значение (в данном случае — 4 000 000). Программа использует стековые операции, работу с переменными и условные конструкции. Рассмотрим программу детально.

#### **1. Описание переменных:**

Программа использует следующие переменные:
- **`odd`**: Хранит текущее нечетное число последовательности Фибоначчи.
- **`even`**: Хранит текущее четное число последовательности Фибоначчи.
- **`sum`**: Хранит сумму четных чисел Фибоначчи, которые не превышают 4 000 000.
- **`two`**: Хранит число 2 для операции нахождения четности.
- **`zero`**: Хранит число 0 для сравнения с остатком от деления.
- **`maximum`**: Максимальное значение для ограничения последовательности (в данном случае 4 000 000).

#### **2. Описание процедуры `fib`:**

```
: fib
    odd @          \ Помещает текущее значение переменной `odd` (нечетного числа Фибоначчи) на вершину стека.
    even @         \ Помещает текущее значение переменной `even` (четного числа Фибоначчи) на стек.
    +              \ Складывает значения переменных `odd` и `even`, результат кладется на стек.
    even @         \ Снова получает текущее четное число и кладет его на стек.
    odd !          \ Сохраняет старое четное число в переменной `odd` как новое нечетное число.
    dup            \ Дублирует результат сложения `odd` и `even` (текущее четное число Фибоначчи).
    dup            \ Еще раз дублирует результат, т. е. на стеке теперь два одинаковых числа.
    even !         \ Сохраняет новое четное число в переменной `even`.
    two @          \ Получает значение 2 для проверки четности числа.
    swap           \ Меняет местами два верхних числа на стеке (число и 2).
    mod            \ Делит число на 2 и кладет остаток от деления на стек (0, если число четное).
    zero @         \ Получает значение переменной `zero` (0) и кладет его на стек.
    =              \ Сравнивает остаток от деления с 0 (если число четное, результат будет 1).
    if
        sum @      \ Если число четное, получает текущую сумму четных чисел Фибоначчи и кладет на стек.
        +          \ Складывает текущее четное число с суммой четных чисел.
        sum !      \ Сохраняет обновленную сумму в переменной `sum`.
    endif
;
```
#### **3. Вывод**
```
 4613732

instraction count -> 1818
tick -> 12501
```

### CI при помощи GH actions

```yml
name: Python CI

on:
  push:
    branches:
      - main
    paths:
      - ".github/workflows/*"
      - "src/**"
  pull_request:
    branches:
      - main
    paths:
      - ".github/workflows/*"
      - "src/**"

defaults:
  run:
    working-directory: ./

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Run tests and collect coverage
        run: |
          poetry run coverage run -m pytest .
          poetry run coverage report -m
        env:
          CI: true

  lint:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Check code formatting with Ruff
        run: poetry run ruff format .

      - name: Run Ruff linters
        run: poetry run ruff check --fix .
```
### Пример Журнала работы
```
[DEBUG]  tick -> 0    ip -> 1   addr -> 1   mc -> 0  control -> AddressRegisterControl.PC tos -> 0     
stack -> []
[DEBUG]  tick -> 1    ip -> 1   addr -> 1   mc -> 0  control -> MemoryControl.READ tos -> 0     
stack -> []
[DEBUG]  tick -> 2    ip -> 1   addr -> 1   mc -> 1  control -> MicrocodeAddressControl.INC tos -> 0     
stack -> []
[DEBUG]  tick -> 3    ip -> 1   addr -> 1   mc -> 1  control -> InstructionRegisterControl.MEM tos -> 0     
stack -> []
[DEBUG]  tick -> 4    ip -> 1   addr -> 1   mc -> 1  control -> InstructionControl.INC tos -> 0     
stack -> []
[DEBUG]  tick -> 5    ip -> 1   addr -> 1   mc -> 44 control -> MicrocodeAddressControl.IR tos -> 0     
stack -> []
[DEBUG]  tick -> 6    ip -> 1   addr -> 1   mc -> 44 control -> DataStackControl.Push tos -> 0     
stack -> []
[DEBUG]  tick -> 7    ip -> 1   addr -> 1   mc -> 45 control -> MicrocodeAddressControl.INC tos -> 0     
stack -> []
[DEBUG]  Input: a
[DEBUG]  tick -> 8    ip -> 1   addr -> 1   mc -> 45 control -> IOOperation.READ tos -> 97    
stack -> []
[DEBUG]  tick -> 9    ip -> 1   addr -> 1   mc -> 45 control -> InstructionControl.INC tos -> 97    
stack -> []
[DEBUG]  tick -> 10   ip -> 2   addr -> 1   mc -> 45 control -> InstractionPointerControl.INC tos -> 97    
stack -> []
[DEBUG]  tick -> 11   ip -> 2   addr -> 1   mc -> 0  control -> MicrocodeAddressControl.ZERO tos -> 97    
stack -> []
[DEBUG]  tick -> 12   ip -> 2   addr -> 2   mc -> 0  control -> AddressRegisterControl.PC tos -> 97    
stack -> []
[DEBUG]  tick -> 13   ip -> 2   addr -> 2   mc -> 0  control -> MemoryControl.READ tos -> 97    
stack -> []
[DEBUG]  tick -> 14   ip -> 2   addr -> 2   mc -> 1  control -> MicrocodeAddressControl.INC tos -> 97    
stack -> []
[DEBUG]  tick -> 15   ip -> 2   addr -> 2   mc -> 1  control -> InstructionRegisterControl.MEM tos -> 97    
stack -> []
[DEBUG]  tick -> 16   ip -> 2   addr -> 2   mc -> 1  control -> InstructionControl.INC tos -> 97    
stack -> []
[DEBUG]  tick -> 17   ip -> 2   addr -> 2   mc -> 12 control -> MicrocodeAddressControl.IR tos -> 97    
stack -> []
[DEBUG]  tick -> 18   ip -> 2   addr -> 2   mc -> 12 control -> DataStackControl.Push tos -> 97    
stack -> [97]
[DEBUG]  tick -> 19   ip -> 2   addr -> 2   mc -> 13 control -> MicrocodeAddressControl.INC tos -> 97    
stack -> [97]
[DEBUG]  tick -> 20   ip -> 3   addr -> 2   mc -> 13 control -> InstractionPointerControl.INC tos -> 97    
stack -> [97]
[DEBUG]  tick -> 21   ip -> 3   addr -> 2   mc -> 13 control -> InstructionControl.INC tos -> 97    
stack -> [97]
```
